# 3차 웹소켓 엔진 리팩토링 코드리뷰: React Front vs React Front-Legacy

**리뷰 날짜**: 2026년 1월 19일  
**리뷰 범위**: WebSocket 연결 구조, 세션 관리, 구독 복구, 인증/토큰 연동 방식  
**대상 프로젝트**:

- Legacy: `캡스톤디자인 Frontend/react-front-legacy`
- New: `react-front`

---

## 📋 목차

1. [아키텍처 개요](#아키텍처-개요)
2. [주요 개선사항](#주요-개선사항)
3. [상세 코드 분석](#상세-코드-분석)
4. [문제점 및 개선 권고사항](#문제점-및-개선-권고사항)
5. [마이그레이션 평가](#마이그레이션-평가)

---

## 🏗️ 아키텍처 개요

### Legacy WebSocket 구조 (Before)

**핵심 파일**:

- [src/components/WebSocket/WebSocketProvider.jsx](../캡스톤디자인%20Frontend/react-front-legacy/src/components/WebSocket/WebSocketProvider.jsx)

```text
WebSocketProvider (1파일 551줄)
 ├ connect / disconnect
 ├ SockJS + STOMP Client 직접 생성
 ├ 토큰 검증 / 토큰 변경 감지
 ├ refresh 이벤트(onTokenRefresh) 처리
 ├ 구독/해제, 구독 복원, 실패/권한 캐시
 ├ 테스트 구독(testSubscribe) 및 location/obd 구독
 └ 토스트/로그/권한 체크까지 모든 책임 집중
```

**문제점**

- WebSocket 관련 거의 모든 로직이 **단일 컴포넌트에 집중 (God Object)**
- React 상태, 토큰 상태, STOMP Client 생명주기, 구독 관리, 에러/권한 처리, 토스트까지 한 파일에서 처리
- React 18 StrictMode, race condition 대응을 위해 ref/타이머 기반 방어 코드가 많아 **복잡도와 진입장벽이 매우 높음**
- WebSocket 레이어가 토큰/인증/권한 세부 구현과 강하게 결합되어 있어 **테스트와 교체가 어려움**

---

### 신규 WebSocket 구조 (After)

**핵심 파일**:

- [src/Context/WebSocketProvider.jsx](../src/Context/WebSocketProvider.jsx)
- [src/WebSocket/WebSocketSession.js](../src/WebSocket/WebSocketSession.js)
- [src/WebSocket/WebSocketClient.js](../src/WebSocket/WebSocketClient.js)
- [src/WebSocket/WebSocketBroker.js](../src/WebSocket/WebSocketBroker.js)

```text
AuthManager / AuthProvider (토큰·로그인 상태)
                ↓ isLoggedIn
WebSocketProvider (Context)
                ↓
WebSocketSession (연결 세션 단위)
                ↓
WebSocketClient (SockJS + STOMP 클라이언트 팩토리)
                ↓
WebSocketBroker (구독/복구 전담)
```

**특징**

- WebSocket을 **4개 레이어**로 분리
  - WebSocketProvider: 로그인 여부에 따라 connect/disconnect만 관리 (UI 레이어)
  - WebSocketSession: STOMP Client 인스턴스와 연결 상태, 에러 이벤트 관리 (Session 레이어)
  - WebSocketClient: SockJS/STOMP 설정, 토큰 주입, 에러 분류 (Client 레이어)
  - WebSocketBroker: topic별 구독/해제 및 재구독 복원 (Broker 레이어)
- 토큰/인증 상태는 토큰엔진에서 설계한 **authManager + AuthProvider** 아키텍처를 그대로 재사용
- WebSocket 레이어는 "**로그인 여부에 따른 연결 및 구독 관리**"에만 집중

---

### 라인 수 및 구조 비교

터미널 측정 결과:

```bash
# 신규
src/Context/WebSocketProvider.jsx     37 lines
src/WebSocket/WebSocketClient.js      58 lines
src/WebSocket/WebSocketSession.js     60 lines
src/WebSocket/WebSocketBroker.js      70 lines
# 합계 225 lines

# 레거시
src/components/WebSocket/WebSocketProvider.jsx 551 lines
```

| 지표                      | Legacy                 | New (합계)                 | 개선 효과       |
| ------------------------- | ---------------------- | -------------------------- | --------------- |
| 파일 수                   | 1개                    | 4개                        | 책임 분리 ↑     |
| WebSocket 관련 라인 수    | 551줄                  | 225줄                      | **약 59% 감소** |
| 책임 분리도               | 매우 낮음 (God Object) | 높음 (SRP 기반 계층 분리)  | 유지보수성 ↑    |
| 아키텍처 일관성(토큰엔진) | 별도 구조              | 토큰엔진 6계층과 철학 공유 | 이해도/일관성 ↑ |

---

## ✨ 주요 개선사항

### 1️⃣ WebSocket 책임의 계층 분리

#### Legacy

- `WebSocketProvider` 한 파일이 다음을 모두 담당:
  - STOMP Client 생성 및 SockJS 연결 로직
  - 토큰 유효성 검사, 토큰 변경 감지, refresh 이벤트(onTokenRefresh) 처리
  - 구독/해제, 재구독 복원, 권한 오류/구독 실패 카운트/차단
  - dispatch별 실시간 위치/OBD 토픽 구독 util
  - 토스트 메시지 및 디버깅 로그 처리
- 결과적으로 **테스트 난이도↑, 유지보수 비용↑, 신규 기여자의 진입장벽↑**

#### New

- 각 레이어가 명확한 단일 책임을 가짐:
  - WebSocketProvider: `isLoggedIn` 변화만 관찰, connect/disconnect 위임
  - WebSocketSession: STOMP Client 인스턴스와 연결 상태(`isConnected`) 및 onConnect/onError 정책 관리
  - WebSocketClient: SockJS URL, heartbeat, reconnectDelay, beforeConnect(토큰 주입), onStompError(401 처리) 캡슐화
  - WebSocketBroker: topic별 listener 관리, `_recoverSubscriptions()`로 재연결 시 구독 복원
- 토큰엔진 6계층과 마찬가지로 **관심사 분리가 잘 되어 있어, 각 레이어를 독립적으로 이해·테스트·교체 가능**

---

### 2️⃣ 인증/토큰 연동 방식 단순화

#### Legacy

- WebSocketProvider 내부에서 직접 `useToken`을 통해
  - `getToken`, `getUserInfo`, `isTokenValid`, `onTokenRefresh` 등을 호출
  - 토큰 만료/갱신/변경 등을 기반으로 connect/disconnect 및 재연결 로직 제어
- 토큰 관련 로직이 WebSocket 레이어에 깊게 침투 →
  - 토큰엔진 변경 시 WebSocket 코드도 함께 바꿔야 하는 구조적 결합

#### New

- **토큰 관리 = 토큰엔진(authManager + tokenStorage + AuthProvider)의 책임**
- WebSocket은 단지 두 가지 신호만 사용:
  1. `AuthProvider`의 `isLoggedIn` (Context)
  2. `authManager.getToken()` (beforeConnect에서만 사용)
- 흐름:

```text
로그인 성공 → authManager.login(token) → AuthProvider.user 세팅
→ isLoggedIn = true → WebSocketProvider.useEffect → webSockSession.connect()
→ WebSocketClient.beforeConnect에서 authManager.getToken()으로 헤더 주입

401/Unauthorized 수신 → WebSocketClient.onStompError
→ authManager.logout() → AuthProvider.user 초기화 → isLoggedIn = false
→ WebSocketProvider.useEffect → webSockSession.disconnect()
```

- 토큰엔진 2차 리뷰에서 강조한 "**토큰은 Storage/Manager에서만 다룬다**"는 원칙을 WebSocket에도 그대로 적용

---

### 3️⃣ WebSocketSession · WebSocketClient로의 역할 분리

#### WebSocketSession (새 구조)

파일: [src/WebSocket/WebSocketSession.js](../src/WebSocket/WebSocketSession.js)

```js
class WebSockSession {
  constructor() {
    this.client = null;
    this.isConnected = false;
    this.connectListeners = new Set();
  }

  connect() {
    if (this.client && this.isConnected) return; // 중복 연결 방지
    this.client = createWebSocketClient({
      onConnect: () => {
        this.isConnected = true;
        this.__notifyConnect();
      },
      onDisconnect: () => {
        this.isConnected = false;
      },
      onError: (error) => {
        /* AUTH/STOMP/NETWORK 분기 처리 */
      },
    });
    this.client.activate();
  }

  disconnect() {
    if (this.client) {
      this.client.deactivate();
      this.client = null;
      this.isConnected = false;
    }
  }

  onConnect(callback) {
    this.connectListeners.add(callback);
    return () => this.connectListeners.delete(callback);
  }
}
```

- 세션 단위로 STOMP Client 인스턴스를 관리하고, 외부에는 `connect()`, `disconnect()`, `onConnect()`만 노출
- Broker 입장에서는 Session 구현을 몰라도 "연결됨" 이벤트만 구독하면 됨 → **결합도 감소**

#### WebSocketClient (새 구조)

파일: [src/WebSocket/WebSocketClient.js](../src/WebSocket/WebSocketClient.js)

```js
const client = new Client({
  webSocketFactory: () => new SockJS(baseURL),
  reconnectDelay: 5000,
  heartbeatIncoming: 4000,
  heartbeatOutgoing: 4000,

  beforeConnect: () => {
    const token = authManager.getToken();
    client.connectHeaders = token ? { Authorization: `Bearer ${token}` } : {};
  },

  onStompError: (frame) => {
    const message = frame.headers["message"];
    if (message?.includes("401") || message?.includes("Unauthorized")) {
      authManager.logout();
      onError?.({ type: "AUTH", message });
      return;
    }
    onError?.({ type: "STOMP", message, frame });
  },

  onWebSocketError: (event) => {
    onError?.({ type: "NETWORK", event });
  },
});
```

- SockJS/STOMP 클라이언트 생성을 WebSocketProvider/Session에서 완전히 분리
- 토큰은 CONNECT 직전에만 읽어서 헤더에 주입 → 안전하고 예측 가능한 타이밍
- AUTH/STOMP/NETWORK 에러를 타입으로 분류해 Session에서 일관되게 처리 가능

---

### 4️⃣ WebSocketBroker를 통한 구독/복구 단순화

파일: [src/WebSocket/WebSocketBroker.js](../src/WebSocket/WebSocketBroker.js)

```js
class WebSocketBroker {
  constructor() {
    this.listeners = new Map(); // topic -> Set<callback>
    this.stompSubscription = new Map();
    webSockSession.onConnect(() => {
      this._recoverSubscriptions(); // 재연결 시 기존 topic 재구독
    });
  }

  subscribe(topic, callback) {
    if (!this.listeners.has(topic)) {
      this.listeners.set(topic, new Set());
    }
    this.listeners.get(topic).add(callback);
    const client = webSockSession.getClient();
    const isConnect = webSockSession.isConnected;

    if (client && isConnect && !this.stompSubscription.has(topic)) {
      this._performStompSubscribe(client, topic);
    }
  }

  _performStompSubscribe(client, topic) {
    const subscription = client.subscribe(topic, (message) => {
      const body = JSON.parse(message.body);
      const listeners = this.listeners.get(topic);
      listeners?.forEach((listener) => listener(body));
    });
    this.stompSubscription.set(topic, subscription);
  }

  _recoverSubscriptions() {
    const client = webSockSession.getClient();
    if (!client || !client.active) return;
    this.listeners.forEach((_, topic) => {
      if (!this.stompSubscription.has(topic)) {
        this._performStompSubscribe(client, topic);
      }
    });
  }
}
```

- topic/구독자 관리 및 재구독 복구 책임을 Provider로부터 분리
- 레거시에서 쓰던 복잡한 실패 카운트/권한 캐시/테스트 구독 로직을 정리하고, **실전에서 필요한 코어 기능만 남김**

---

## 🔍 상세 코드 분석

### A. WebSocketProvider.jsx (Context 레이어)

파일: [src/Context/WebSocketProvider.jsx](../src/Context/WebSocketProvider.jsx)

```jsx
export const WebSocketProvider = ({ children }) => {
  const { isLoggedIn } = useAuthContext();

  useEffect(() => {
    if (isLoggedIn) {
      webSockSession.connect();
    } else {
      webSockSession.disconnect();
    }

    return () => {
      webSockSession.disconnect();
    };
  }, [isLoggedIn]);

  return (
    <webSocketContext.Provider value={{ webSockSession }}>
      {children}
    </webSocketContext.Provider>
  );
};
```

**평가**

- `isLoggedIn` 상태 변화만 감지하여 WebSocketSession에 명령을 위임 → 의도가 매우 명확
- cleanup에서 항상 `disconnect()`를 호출해 컴포넌트 언마운트 시 리소스 정리 보장
- Context 값으로 세션 객체만 노출하므로, 세션 구현 변경 시 상위 UI는 영향을 거의 받지 않음

**개선 여지**

- `useToast`를 import만 하고 사용하지 않음 → 제거 필요 (불필요 의존성)
- `webSockSession`뿐 아니라 `isConnected` 같은 파생 상태도 Context로 같이 노출하면, 훅/컴포넌트 사용성이 개선될 수 있음

---

### B. WebSocketSession.js (Session 레이어)

**장점**

- `connect()`에서 이미 연결되어 있으면 즉시 return → 중복 `activate()` 호출 방지
- 에러 타입별로 행동을 분리:
  - `AUTH`: 세션 종료 및 client.deactivate()
  - `STOMP`: 프로토콜 에러 로그
  - `NETWORK`: 네트워크 불안정 경고
- `onConnect()`/`__notifyConnect()`를 통해 Broker 등 외부 객체가 연결 이벤트만 구독할 수 있음

**개선 여지**

- `AUTH` 케이스에서 `this.disconnect();` 호출 후 `this.client?.deactivate();`를 다시 호출하는 부분은 의미상 중복이므로, 하나로 통일하면 의도가 더 명확해짐
- 현재 `isConnected`는 public field로, Broker에서 직접 참조함. `getIsConnected()` 같은 getter를 도입하면 캡슐화와 향후 리팩토링에 유리

---

### C. WebSocketClient.js (Client 레이어)

**장점**

- SockJS URL, heartbeat, reconnectDelay 등 클라이언트 설정을 한 곳에서 관리하므로, 인프라/네트워크 전략 변경 시 변경 지점이 명확
- `beforeConnect`에서 매번 `authManager.getToken()`을 호출해 최신 토큰을 헤더에 주입 → 토큰엔진과 정렬된 패턴
- 401/Unauthorized 시 `authManager.logout()`을 호출하고, 나머지 에러는 `STOMP`/`NETWORK` 타입으로 분류해 상위(Session)에서 일관된 정책을 적용 가능

**개선 여지**

- `REACT_APP_WS_URL`이 필수값이므로, `.env` 문서에 필수 항목과 예시를 명시하는 것이 안전
- `onStompError`에서 메시지 포맷이 다양할 수 있으므로, 토큰엔진에서처럼 `{ type, status, message }` 형태로 정규화하면 로그 분석 및 모니터링 도구 연동에 유리

---

### D. WebSocketBroker.js (Broker 레이어)

**장점**

- topic별로 여러 listener를 Set으로 관리 → 동일 topic에 대한 다수 컴포넌트 구독을 자연스럽게 지원
- 세션 재연결 시 `_recoverSubscriptions()`가 기존 topic 목록을 기준으로 자동 재구독 수행 → 레거시의 핵심 요구사항(구독 복구)을 단순한 방식으로 충족
- 레거시에서 필요 이상으로 복잡했던 subscribe 실패/권한 캐시/테스트 구독 로직을 제거해, **실전에서 꼭 필요한 부분만 남긴 얇은 Broker** 구조

**개선 여지**

- 현재는 권한 거부/구독 실패에 대한 별도의 backoff/차단 정책이 없음. 서버 설정 오류나 권한 문제로 특정 topic이 계속 실패하는 경우, 재연결마다 무한 반복 시도가 발생할 수 있음 → 레거시의 `3회 연속 실패 시 차단`과 유사한 간단한 정책 도입을 고려할 만함
- JSON 파싱 실패 시 `console.log('구독 실패')` 수준의 정보만 남기는데, topic명과 원본 body를 포함해 로그를 남기면 디버깅이 훨씬 용이

---

## ⚠️ 문제점 및 개선 권고사항

### 1️⃣ Critical (P0)

1. **AUTH 에러 처리 시 중복 deactivate 정리**

   - `WebSocketSession.onError`에서 `AUTH` case:
     - `this.disconnect()` 내부에서 이미 `client.deactivate()` 및 `client = null` 처리
     - 이후 `this.client?.deactivate()`는 실질적으로 no-op → 하나로 통합해 의도를 명확히 할 것

2. **불필요 import 제거**

   - `WebSocketProvider.jsx`에서 사용하지 않는 `useToast` 제거 → 코드 노이즈 및 의존성 최소화

3. **환경 변수 문서화**
   - `REACT_APP_WS_URL` 값이 없을 경우 WebSocket 연결이 조용히 실패할 수 있음
   - 토큰엔진 리뷰처럼 `.env` 예시와 필수 여부를 README/환경 설정 문서에 명시할 것을 권고

---

### 2️⃣ Major (P1)

1. **Broker의 구독 실패 백오프 도입**

   - 현재 `_performStompSubscribe`는 실패 시 재시도 정책이 없음
   - 서버 설정 오류, 권한 문제 등으로 특정 topic이 계속 실패하는 경우, 재연결 때마다 반복 시도가 발생 가능
   - 레거시에서 사용하던 `failCount >= 3 → blocked` 정도의 단순 정책을 이식하면 운영 안정성이 향상됨

2. **WebSocket 상태를 Context로 노출**

   - 현재 Context 값은 `{ webSockSession }`만 포함 → 사용 측에서 세션 내부 구현에 의존하게 됨
   - 예: `{ webSockSession, isConnected: webSockSession.isConnected }` 정도만 추가해도 UI/훅에서 상태 사용이 쉬워지고, 세션 구현 변경시 영향 범위가 줄어듦

3. **에러 로깅 표준화**
   - 토큰엔진의 apiClient처럼 최소 `{ type, message, detail }` 포맷으로 WebSocket 에러를 정규화해두면 Sentry/로그 수집 도구 연동 시 큰 이점을 가짐

---

### 3️⃣ Minor (P2)

1. **재연결 전략 고도화**

   - 현재 STOMP의 `reconnectDelay`에 주로 의존
   - 필요 시, Session 레벨에서 "N초 이내 M회 실패 시 사용자에게 안내 후 자동 재시도 중단"과 같은 전략을 도입하면 UX 향상

2. **단위 테스트 도입**

   - WebSocketSession, WebSocketClient, WebSocketBroker 모두 순수 JS 클래스로, Jest 등으로 테스트 작성이 용이
   - 최소한 다음 시나리오는 테스트로 잡아두는 것을 권장:
     - 토큰이 없는 상태에서 `connect()` 호출 시 동작
     - AUTH 에러 발생 시 `authManager.logout()`까지의 흐름
     - Broker의 subscribe/unsubscribe/recover 로직

3. **타입 안정성 (TypeScript 마이그레이션 고려)**
   - topic 문자열, 콜백 시그니처, 에러 타입(`"AUTH" | "STOMP" | "NETWORK"`) 등이 명시적인 enum/타입으로 정의되면 컴파일 타임에 많은 버그를 사전에 차단 가능

---

## 📊 마이그레이션 평가

### 코드 메트릭 비교

| 메트릭                | Legacy                      | New                            | 개선율/평가     |
| --------------------- | --------------------------- | ------------------------------ | --------------- |
| 핵심 WebSocket 라인수 | 551줄 (1파일)               | 225줄 (4파일 합계)             | **약 59% 감소** |
| 책임 분리             | 2/10 (단일 컴포넌트에 집중) | 9/10 (레이어별 분리)           | SRP 준수        |
| 이해도                | 낮음                        | 높음                           | 가독성 ↑        |
| 테스트 용이성         | 매우 낮음                   | 높음 (클래스/함수 단위 테스트) | 테스트 가능성 ↑ |
| 아키텍처 일관성       | 토큰엔진과 분리된 느낌      | 토큰엔진 6계층과 철학 공유     | 시스템 일관성 ↑ |

### 아키텍처 점수 (10점 만점)

**Legacy**

- 계층 분리: 2/10 (WebSocketProvider에 과도한 책임 집중)
- 재사용성: 3/10 (특정 페이지/도메인에 종속된 로직 다수)
- 유지보수성: 3/10 (복잡한 상태/타이머/refs)
- 테스트 가능성: 2/10 (React 컴포넌트 내부에 모든 로직 존재)
- 확장성: 3/10 (새 토픽/도메인 추가 시 부담 큼)
- **총점: 13/50 (26%)**

**New**

- 계층 분리: 9/10 (Provider/Session/Client/Broker 분리)
- 재사용성: 8/10 (Broker/Session 재사용 용이)
- 유지보수성: 9/10 (각 파일 60줄 내외, 역할 명확)
- 테스트 가능성: 8/10 (함수/클래스 단위 테스트 쉬움)
- 확장성: 9/10 (새 도메인 소켓 훅/토픽 추가 용이)
- **총점: 43/50 (86%)**

---

## 🎯 결론

### 잘된 점

- ✅ WebSocket 구조를 **단일 거대 컴포넌트에서 4개 레이어로 분리**해, 토큰엔진 6계층과 유사한 수준의 관심사 분리를 달성했습니다.
- ✅ 인증/토큰 관련 책임을 WebSocket 레이어에서 제거하고, `authManager + AuthProvider`를 Single Source of Truth로 삼아 일관성을 확보했습니다.
- ✅ WebSocketSession/WebSocketClient/WebSocketBroker 각각이 명확한 책임을 가지며, 가독성과 테스트 가능성이 크게 향상되었습니다.
- ✅ 레거시에서 필요 이상으로 복잡했던 subscribe 실패/권한 캐시/테스트 구독 로직을 정리하고, 실제 서비스에 꼭 필요한 기능만 남긴 점이 좋습니다.

### 보완하면 좋은 점

- ⚠️ AUTH 에러 처리 시 중복 deactivate 정리, 불필요 import 제거 등 작은 클린업이 남아 있습니다.
- ⚠️ Broker 레벨에서 간단한 구독 실패 백오프 정책을 도입하면, 운영 시 예기치 못한 무한 재시도 상황을 방지할 수 있습니다.
- ⚠️ WebSocket 상태/에러를 표준화하고 Context/Hooks에서 활용하면, UI 측에서 더 풍부한 사용자 피드백을 제공할 수 있습니다.

### 최종 평가

이번 WebSocket 리팩토링은 **토큰엔진 리팩토링에 이은 자연스러운 두 번째 단계**로, 프론트엔드 전체 아키텍처를 일관된 방향으로 끌어올렸다는 점에서 매우 의미 있습니다.

- Legacy 구조에 비해 코드량은 **약 59% 감소**했지만, 표현력과 안정성은 오히려 더 좋아졌습니다.
- 토큰엔진/인증 시스템과의 결합 방식이 깔끔해져, 향후 인증 정책 변경이나 WebSocket 기능 확장에도 유연하게 대응할 수 있는 구조입니다.

**종합적으로, WebSocket 레이어 리팩토링은 성공적이며, 남은 P0/P1 사항들(환경변수 문서화, 소소한 클린업, 간단한 백오프 정책, 최소 단위 테스트)을 보완하면 프로덕션 수준에서도 충분히 신뢰할 수 있는 품질이라고 판단됩니다.**

---

**작성자**: Code Review Bot  
**작성일**: 2026년 1월 19일  
**최종 평가**: ⭐⭐⭐⭐☆ (4.5/5) - 구조적으로 매우 잘 된 리팩토링, 일부 운영 측면 고도화 여지 있음
