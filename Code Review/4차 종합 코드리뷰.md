### 표 1. 코드 규모 & 구조 메트릭 (Legacy vs New)

| 항목                        | Legacy (`react-front-legacy`) | New (`react-front`) | 변화량/비율                        | 해석                                       |
| --------------------------- | ----------------------------- | ------------------- | ---------------------------------- | ------------------------------------------ |
| JS/JSX 파일 수 (`src`)      | 69                            | 81                  | **+12 파일, +17.4%**               | 파일 수는 늘었지만 기능별 분리가 진행됨    |
| 총 LOC (`src`, JS/JSX)      | 12,221                        | 7,915               | **-4,306줄, -35.2%**               | 전체 코드량 크게 감소 → 응집도↑, 중복↓     |
| hooks 파일 수 (`src/hooks`) | 9                             | 14                  | **+5 파일, +55.6%**                | 페이지/도메인 로직을 훅 레이어로 적극 분리 |
| components 파일 수          | 38                            | 36                  | -2 파일, -5.3%                     | UI 컴포넌트 수는 비슷, 덩치는 작아짐       |
| pages 파일 수               | 15                            | 13                  | -2 파일, -13.3%                    | 일부 페이지가 재조합·단순화                |
| WebSocket 관련 LOC          | 551 (1파일)                   | 225 (4파일 합산)    | **-326줄, -59.2%**                 | God Object → 4계층 분리, 책임 축소         |
| 라우팅 temp vs Routes LOC   | 108 vs 54                     | 54 (Routes 유지)    | **-50.0% (이미 1차에서 개선완료)** | 라우팅 레이어는 이미 DRY, SRP 잘 지켜짐    |
| 라우팅 중복 코드 라인       | 30줄                          | 0줄                 | **-100%**                          | 중복 제거 완료                             |
| WebSocket 파일 수           | 1                             | 4                   | +3 파일                            | Session/Client/Broker/Provider로 계층 분리 |

**요약**

- “굵은 줄기” 리팩토링(라우팅, 토큰엔진, WebSocket)이 끝난 상태답게,  
  **코드량은 크게 줄었는데(–35.2%), 아키텍처 레이어 수와 훅 수는 늘어난 구조**입니다.
- 특히 WebSocket·토큰·라우팅이 각자 **전담 레이어**를 갖게 되어, 레거시에 비해 “어디를 수정해야 할지”가 훨씬 명확합니다.

---

## 2. 품질/아키텍처 관점 수치화 비교

> 기존 1·2·3차 리뷰 수치 + 현재 구조를 종합한 정성 평가를 수치화한 값입니다.

### 표 2. 품질·아키텍처 지표 (0–100 점수화)

| 카테고리              | Legacy | New    | 변화량            | 설명                                                                                         |
| --------------------- | ------ | ------ | ----------------- | -------------------------------------------------------------------------------------------- |
| 가독성(Readability)   | 60     | 87     | **+27**           | 라우팅/토큰/WebSocket 핵심 파일 길이 감소, 역할 분리, 네이밍 개선                            |
| 유지보수성(Maintain.) | 55     | 90     | **+35**           | 토큰 6계층 + WebSocket 4계층 + Page Hook 구조 도입                                           |
| 재사용성(Reusability) | 50     | 88     | **+38**           | `useAuthPage`, `useOperatingSchedule`, `useInsightData`, `useLiveDispatch`, QueryLayer 훅 등 |
| 확장성(Scalability)   | 52     | 89     | **+37**           | API/Service/Query/Hook/Context/WebSocket이 느슨하게 결합                                     |
| 테스트 용이성         | 40     | 72     | **+32**           | 레이어 분리로 단위 테스트 포인트는 많아졌으나, 아직 실제 테스트는 없음                       |
| 성능/런타임 효율      | 65     | 82     | **+17**           | 불필요 중복 렌더/중복 로직 감소, WebSocket 연결/구독 로직 단순화                             |
| 보안/인증 안정성      | 58     | 88     | **+30**           | 중앙 토큰 스토리지, API 인터셉터, 401/refresh 일관 처리                                      |
| 실시간 기능 안정성    | 50     | 85     | **+35**           | WebSocket 세션/브로커 분리, 재구독·에러 분류 구조화                                          |
| 코드 일관성/규칙성    | 55     | 86     | **+31**           | 경로 구조, 네이밍, 레이어링이 전체적으로 통일됨                                              |
| **종합 품질 점수**    | **54** | **86** | **+32 (약 +59%)** | 레거시 대비 “한 세대” 업그레이드에 가까운 수준                                               |

---

## 3. 최종 종합 요약 표

### 표 3. 리팩토링 전후 종합 비교(전역 요약)

| 축/관점                  | Legacy (Before)                                                                 | New (After, 현재 상태)                                                                                                   | 한줄 총평                                                     |
| ------------------------ | ------------------------------------------------------------------------------- | ------------------------------------------------------------------------------------------------------------------------ | ------------------------------------------------------------- |
| 아키텍처 레이어링        | 페이지 안에 axios/토큰/비즈니스 로직 뒤섞임<br>WebSocket God Object 1파일 551줄 | UI → Page Hook → Query Hook → Service → API Client → Token Storage<br>+ WebSocket 4계층 (Provider/Session/Client/Broker) | “레이어를 의식하고 설계하는 프로젝트” 수준으로 상승           |
| 코드 규모/중복           | 파일은 적지만, 한 파일당 덩치 크고 중복 다수                                    | 파일/훅 수는 늘었지만, LOC는 -35.2%, 중복/조건 분기 크게 감소                                                            | “잘게 나뉜 적당한 조각들”에 가깝게 정리됨                     |
| 인증/토큰 엔진           | 페이지별 직접 localStorage/axios, 만료·갱신 로직 산재                           | 6계층 토큰 엔진 + 중앙 apiClient 인터셉터 + AuthContext + authManager                                                    | 프론트 기준으로는 충분히 ‘엔터프라이즈 급’ 구조               |
| WebSocket/실시간         | WebSocketProvider 1파일이 연결/토큰/구독/토스트 전부 담당                       | WebSocketProvider ↔ Session ↔ Client ↔ Broker로 책임 분리, 401/토큰/재구독 흐름 명확                                     | 실시간 레이어가 나머지와 느슨하게 결합됨                      |
| 도메인 페이지 구조       | 페이지 안에 API 호출·상태·UI 혼재                                               | `useOperatingSchedule`, `useInsightData`, `useLiveDispatch` 등 Page Custom Hook 레이어 확립                              | “페이지 = 뷰 + 약간의 orchestration”으로 정리                 |
| 오류 처리/에러 모델      | axios 호출마다 각자 try-catch 또는 무처리                                       | apiClient 레벨에서 공통 에러 정규화, Toast/Context/Hooks에서 재사용                                                      | 디버깅·사용자 피드백 품질 상승                                |
| 실무 적용 난이도(온보딩) | 진입 시 어느 파일부터 봐야 할지 모호                                            | App/RoutesComponents/Context/WebSocket/Token의 역할이 뚜렷, 코드리뷰 문서까지 있어 맥락 추적 쉬움                        | 신입/후임자 온보딩 시간 크게 단축 예상                        |
| 테스트/검증 기반         | 구조상 테스트 포인트가 적고, UI와 로직이 섞임                                   | 레이어별로 테스트 포인트는 충분히 생겼으나, 아직 실제 테스트 코드 부재                                                   | “테스트 가능한 구조”는 되었고, 이제 “테스트를 쓰면 되는” 단계 |
| 남은 리스크/빚           | 구조적 빚 + 로직 빚이 혼재                                                      | 구조적 빚은 대부분 해소, 로직 상세/에지 케이스/타입 세분화 등 “마감 작업” 위주                                           | 핵심 뼈대는 완성, 마감 공정이 남은 상태                       |

---

## 4. 종합 코드리뷰 (장점 & 다음 단계)

### 4.1 잘된 점 (긍정적인 부분)

- **토큰엔진 6계층 + WebSocket 4계층 + Page Hook 레이어**
  - App / Routes / AuthProvider / WebSocketProvider / Page Hooks / Query Hooks / Service / apiClient / tokenStorage 구조가 **일관되게 관통**합니다.
  - 실제 수치로도 WebSocket 551줄 → 225줄(–59.2%)로 책임 범위가 명확히 줄어들었고, 토큰엔진도 페이지에서 완전히 분리되었습니다.

- **PageCustomHook 패턴 정착**
  - `useAuthPage`, `useOperatingSchedule`, `useInsightData`, `useLiveDispatch` 등으로 **페이지별 비즈니스 로직이 훅 레이어에 모여 있음**.
  - `pages`는 라우팅/간단 상태/뷰 조합만 담당해서, 추후 디자인 변경·API 변경 시 영향 범위가 예측 가능.

- **AuthGate / PrivateShell / ProtectedLayout 구조**
  - `RoutesComponents.jsx`에서 `AuthGate`와 `ProtectedLayout`을 통해 로그인 체크와 레이아웃을 한 번에 처리하는 패턴이 깔끔합니다.
  - `App.jsx`에서 “공개 경로(로그인 전)”와 “보호 경로(로그인 후, WebSocket/Notification 활성)”를 명확히 분리한 것도 매우 좋습니다.

- **Context 활용이 목적에 정확히 맞음**
  - AuthContext: 인증 상태/로그아웃/유저 캐시 무효화 등을 담당.
  - NotificationProvider, WebSocketProvider: 실시간/알림 레이어를 보호 경로 안에서만 활성화.
  - “전역이 필요한 것만 Context로 올리고, 나머지는 훅/서비스로 내리는” 의식이 잘 지켜져 있습니다.

- **문서화 수준**
  - 1·2·3차 코드리뷰 문서 자체가 이미 반쯤 설계 문서 + 회고록 역할을 하고 있어서, 프로젝트 전반의 맥락을 이해하기가 쉽습니다.
  - 이 정도 텍스트/수치가 쌓여 있으면, 팀 단위 개발/유지보수 시 큰 자산이 됩니다.

### 4.2 보완하면 좋은 점 (다음 리팩토링 스텝 제안)

1. **테스트 레이어 도입 (지금 구조면 “바로 쓸 수 있는” 상태)**
   - 추천 순서:
     - tokenStorage / authManager 단위 테스트 (만료/refresh/로그아웃 경로)
     - WebSocketClient (토큰 주입, 401 분기) 테스트 – 실제 소켓 대신 mock/stub으로.
     - PageCustomHook 중 순수 비즈니스 로직 비율이 높은 `useOperatingSchedule`부터 테스트.
   - 이렇게 3~5개만 잡아도 “패턴”이 잡혀서 이후 확장이 쉬워집니다.

2. **타입 안정성(또는 최소한의 스키마) 강화**
   - 현재는 JS + React Query 조합으로 잘 짜여 있지만, API 응답 스키마가 암묵적으로만 존재합니다.
   - 선택지:
     - `zod`/`yup` 같은 runtime 스키마로 Service Layer에서 validate
     - 혹은 장기적으로 TypeScript 전환을 고려.
   - 특히 WebSocket payload나 OBD/위치 데이터는 스키마를 명시해두면, 프런트·백 간 커뮤니케이션이 훨씬 안전해집니다.

3. **스타일/클래스 네이밍의 일부 일관성 보강**
   - 대부분 Tailwind를 잘 쓰고 있지만, `Insight`의 `InlineKpi`처럼 `bg-${tone}-50` 형태의 **동적 클래스**는 Tailwind purge 설정에 따라 누락될 수 있습니다.
   - 이 부분만 `clsx` + safelist 혹은 미리 정의한 `toneToClass` 맵으로 정적 문자열로 바꿔주면, 예기치 못한 스타일 누락 리스크를 줄일 수 있습니다.

4. **디렉터리 레벨에서의 “도메인 모듈” 묶음 고려**
   - 이미 `Dashboard/`, `Schedule/`, `Driver/` 등 컴포넌트 폴더는 잘 정리되어 있습니다.
   - 다음 단계로는 “도메인 단위 모듈” (`modules/dispatch`, `modules/driver` 등)을 만들어:
     - hook + service + query + 타입(또는 스키마)을 한 묶음으로 바라보는 구조도 고려해 볼 수 있습니다.
   - 지금 단계에서는 필수는 아니고, 팀/프로젝트 규모가 더 커질 때 고려하면 좋을 수준입니다.

---

## 5. 한 줄 총평

- **수치적으로도(LOC –35.2%, WebSocket 라인 –59.2%, 품질 점수 54 → 86)**,  
  **구조적으로도(6계층 토큰엔진 + 4계층 WebSocket + Page Hook 레이어)**  
  레거시에 비해 “한 세대” 올라간 아키텍처입니다.
- 이제는 “뼈대/관통하는 굵은 줄기”는 충분히 정리됐고,  
  **테스트·타입·세부 일관성(동적 클래스 등) 같은 마감 작업**을 하면, 실서비스 기준으로도 꽤 탄탄한 프론트엔드가 될 수준입니다.
